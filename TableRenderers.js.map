{"version":3,"sources":["src/TableRenderers.jsx"],"names":["makeRenderer","TableRenderer","stubEntry","stubId","headerEntry","headerAttr","userResponses","props","headerOptionId","id","forEach","entry","baseScore","stubScore","stubScores","response","value","cells","map","score","Math","round","headerData","headerKeys","missingValues","flatMap","find","record","missingRaw","missingValue","headerId","total","pivotData","PivotData","stubFilters","stubValueFilter","headerFilters","headerValueFilter","data","dCopy","Object","assign","dB","key","keys","options","values","filter","filterProp","filterValues","option","text","stubData","stubKeys","stubs","headers","currKey","headerEntries","i","headerFullEntry","headerOptions","headerOption","getHeaderBase","stubKey","stubOption","j","showStubLabel","objs","length","qLabelRowSpan","calculateCell","calculateMissingValues","React","Component","defaultProps","propTypes","tableOptions","PropTypes","object","Table"],"mappings":"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","file":"TableRenderers.js","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport {PivotData} from './Utilities';\n\nfunction makeRenderer() {\n  class TableRenderer extends React.Component {\n    calculateCell(stubEntry, stubId, headerEntry, headerAttr) {\n      const {userResponses} = this.props;\n      const headerOptionId = headerEntry.id;\n\n      headerEntry[headerAttr].forEach(entry => {\n        entry.baseScore = 0;\n        entry.stubScore = 0;\n\n        if (!entry.stubScores) {\n          entry.stubScores = {};\n        }\n      });\n\n      userResponses.forEach(response => {\n        headerEntry[headerAttr].forEach(entry => {\n          if (!entry.stubScores[headerAttr]) {\n            entry.stubScores[headerAttr] = {};\n          }\n\n          if (response[headerOptionId] === entry.value) {\n            entry.baseScore++;\n\n            if (!entry.stubScores[headerAttr][stubId]) {\n              entry.stubScores[headerAttr][stubId] = 0;\n            }\n\n            if (response[stubId] === stubEntry.value) {\n              entry.stubScore++;\n              entry.stubScores[headerAttr][stubId] += 1;\n            }\n          }\n        });\n      });\n\n      const cells = headerEntry[headerAttr].map(entry => {\n        const score = Math.round((entry.stubScore / entry.baseScore) * 100);\n\n        return <td>{`${score ? score : 0}%`}</td>;\n      });\n\n      return cells;\n    }\n\n    calculateMissingValues(headerData, headerKeys, stubId) {\n      const missingValues = headerKeys.flatMap(headerAttr => {\n        const headerEntry = headerData.find(record =>\n          record[headerAttr] ? record : null\n        );\n\n        return headerEntry[headerAttr].map(entry => {\n          const missingRaw =\n            entry.baseScore - entry.stubScores[headerAttr][stubId];\n          const missingValue = Math.round((missingRaw / entry.baseScore) * 100);\n\n          return missingValue ? missingValue : 0;\n        });\n      });\n\n      return missingValues;\n    }\n\n    getHeaderBase(headerEntry, headerId) {\n      const {userResponses} = this.props;\n      let total = 0;\n\n      userResponses.forEach(response => {\n        if (response[headerId] === headerEntry.value) {\n          total++;\n        }\n      });\n\n      return total;\n    }\n\n    render() {\n      const pivotData = new PivotData(this.props);\n\n      const stubFilters = pivotData.props.stubValueFilter;\n      const headerFilters = pivotData.props.headerValueFilter;\n\n      const headerData = pivotData.props.data.map(dB => {\n        const dCopy = Object.assign({}, dB);\n        const key = Object.keys(dCopy)[0];\n        const options = Object.values(dCopy)[0].filter(option => {\n          for (const filterProp in headerFilters) {\n            const filterValues = headerFilters[filterProp];\n            if (filterValues[option.text]) {\n              return false;\n            }\n          }\n          return true;\n        });\n\n        dCopy[key] = options;\n        return dCopy;\n      });\n\n      const stubData = pivotData.props.data.map(dB => {\n        const dCopy = Object.assign({}, dB);\n        const key = Object.keys(dCopy)[0];\n        const options = Object.values(dCopy)[0].filter(option => {\n          for (const filterProp in stubFilters) {\n            const filterValues = stubFilters[filterProp];\n            if (filterValues[option.text]) {\n              return false;\n            }\n          }\n          return true;\n        });\n\n        dCopy[key] = options;\n        return dCopy;\n      });\n\n      const stubKeys = pivotData.props.stubs;\n      const headerKeys = pivotData.props.headers;\n      let currKey = '';\n\n      return (\n        <table className=\"pvtTable\">\n          <thead>\n            <tr>\n              <td colSpan=\"2\"></td>\n              {headerKeys.map(headerAttr => {\n                const headerEntries = headerData.find(record =>\n                  record[headerAttr] ? record : null\n                )[headerAttr];\n                return headerEntries.map((headerEntry, i) => {\n                  return (\n                    <th className=\"pvtColLabel\" key={`headerKey${i}`}>\n                      {headerEntry.text}\n                    </th>\n                  );\n                });\n              })}\n            </tr>\n            <tr>\n              <th colSpan=\"2\">Base</th>\n              {headerKeys.map(headerAttr => {\n                const headerFullEntry = headerData.find(record =>\n                  record[headerAttr] ? record : null\n                );\n                const headerOptions = headerFullEntry[headerAttr];\n\n                return headerOptions.map((headerOption, i) => {\n                  return (\n                    <th className=\"pvtColLabel\" key={`headerKey${i}`}>\n                      {this.getHeaderBase(headerOption, headerFullEntry.id)}\n                    </th>\n                  );\n                });\n              })}\n            </tr>\n          </thead>\n\n          <tbody>\n            {stubKeys.map((stubKey, i) => {\n              const stubEntry = stubData.find(record =>\n                record[stubKey] ? record : null\n              );\n\n              return stubEntry[stubKey].map((stubOption, j) => {\n                let showStubLabel = true;\n\n                if (i === 0) {\n                  headerKeys.map(headerAttr => {\n                    const headerOptions = headerData.find(record =>\n                      record[headerAttr] ? record : null\n                    );\n\n                    if (headerOptions[headerAttr]) {\n                      headerOptions[headerAttr].forEach(headerOption => {\n                        if (headerOption.stubScores) {\n                          const objs = Object.values(\n                            headerOption.stubScores[headerAttr]\n                          );\n\n                          if (objs.length > 0) {\n                            headerOption.stubScores[headerAttr] = {};\n                          }\n                        }\n                      });\n                    }\n                  });\n                }\n\n                if (currKey !== stubKey) {\n                  currKey = stubKey;\n                } else {\n                  showStubLabel = false;\n                }\n\n                const qLabelRowSpan = stubEntry[stubKey].length;\n\n                return (\n                  <React.Fragment>\n                    <tr key={`stubKeyRow${i}`}>\n                      {showStubLabel && (\n                        <th\n                          key={`stubKeyLabel2${i}-${j}`}\n                          rowSpan={qLabelRowSpan}\n                        >\n                          {stubKey}\n                        </th>\n                      )}\n                      <th key={`stubKeyLabel${i}-${j}`} className=\"pvtRowLabel\">\n                        {stubOption.text}\n                      </th>\n                      {headerKeys.map(headerAttr => {\n                        const headerEntry = headerData.find(record =>\n                          record[headerAttr] ? record : null\n                        );\n\n                        return this.calculateCell(\n                          stubOption,\n                          stubEntry.id,\n                          headerEntry,\n                          headerAttr\n                        );\n                      })}\n                    </tr>\n                    {[true].map(_ => {\n                      const missingValues = this.calculateMissingValues(\n                        headerData,\n                        headerKeys,\n                        stubEntry.id\n                      );\n                      if (\n                        j === stubEntry[stubKey].length - 1 &&\n                        missingValues.filter(value => value > 0).length > 0\n                      ) {\n                        return (\n                          <tr>\n                            <td></td>\n                            <th key={`stubKeyLabel2${i}-${j}-${j}`}>\n                              Missing Values\n                            </th>\n                            {missingValues.map(missingValue => {\n                              return <td>{missingValue}%</td>;\n                            })}\n                          </tr>\n                        );\n                      }\n\n                      return null;\n                    })}\n                  </React.Fragment>\n                );\n              });\n            })}\n          </tbody>\n        </table>\n      );\n    }\n  }\n\n  TableRenderer.defaultProps = PivotData.defaultProps;\n  TableRenderer.propTypes = PivotData.propTypes;\n  TableRenderer.defaultProps.tableOptions = {};\n  TableRenderer.propTypes.tableOptions = PropTypes.object;\n  return TableRenderer;\n}\n\nexport default {\n  Table: makeRenderer(),\n};\n"]}